{
  "version": 3,
  "sources": ["../vue-meta/dist/vue-meta.esm-bundler.js"],
  "sourcesContent": ["/**\n * vue-meta v3.0.0-alpha.10\n * (c) 2022\n * - Pim (@pimlie)\n * - All the amazing contributors\n * @license MIT\n */\n\nimport { markRaw, h, getCurrentInstance, isProxy, watch, inject, defineComponent, reactive, onUnmounted, Teleport, Comment, computed } from 'vue';\n\nconst resolveOption = (predicament, initialValue) => (options, contexts) => {\r\n    let resolvedIndex = -1;\r\n    contexts.reduce((acc, context, index) => {\r\n        const retval = predicament(acc, context);\r\n        if (retval !== acc) {\r\n            resolvedIndex = index;\r\n            return retval;\r\n        }\r\n        return acc;\r\n    }, initialValue);\r\n    if (resolvedIndex > -1) {\r\n        return options[resolvedIndex];\r\n    }\r\n};\n\nconst setup = (context) => {\r\n    let depth = 0;\r\n    if (context.vm) {\r\n        let { vm } = context;\r\n        do {\r\n            if (vm.parent) {\r\n                depth++;\r\n                vm = vm.parent;\r\n            }\r\n        } while (vm && vm.parent && vm !== vm.root);\r\n    }\r\n    context.depth = depth;\r\n};\r\nconst resolve = resolveOption((currentValue, context) => {\r\n    const { depth } = context;\r\n    if (!currentValue || depth > currentValue) {\r\n        return depth;\r\n    }\r\n    return currentValue;\r\n});\n\nvar defaultResolver = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  setup: setup,\n  resolve: resolve\n});\n\nconst defaultConfig = {\r\n    body: {\r\n        tag: 'script',\r\n        to: 'body'\r\n    },\r\n    base: {\r\n        valueAttribute: 'href'\r\n    },\r\n    charset: {\r\n        tag: 'meta',\r\n        nameless: true,\r\n        valueAttribute: 'charset'\r\n    },\r\n    description: {\r\n        tag: 'meta'\r\n    },\r\n    og: {\r\n        group: true,\r\n        namespacedAttribute: true,\r\n        tag: 'meta',\r\n        keyAttribute: 'property'\r\n    },\r\n    twitter: {\r\n        group: true,\r\n        namespacedAttribute: true,\r\n        tag: 'meta'\r\n    },\r\n    htmlAttrs: {\r\n        attributesFor: 'html'\r\n    },\r\n    headAttrs: {\r\n        attributesFor: 'head'\r\n    },\r\n    bodyAttrs: {\r\n        attributesFor: 'body'\r\n    }\r\n};\n\n/*\r\n * This is a fixed config for real HTML tags\r\n */\r\nconst tags = {\r\n    title: {\r\n        attributes: false\r\n    },\r\n    base: {\r\n        contentAsAttribute: true,\r\n        attributes: ['href', 'target']\r\n    },\r\n    meta: {\r\n        contentAsAttribute: true,\r\n        keyAttribute: 'name',\r\n        attributes: ['content', 'name', 'http-equiv', 'charset']\r\n    },\r\n    link: {\r\n        contentAsAttribute: true,\r\n        attributes: [\r\n            'href',\r\n            'crossorigin',\r\n            'rel',\r\n            'media',\r\n            'integrity',\r\n            'hreflang',\r\n            'type',\r\n            'referrerpolicy',\r\n            'sizes',\r\n            'imagesrcset',\r\n            'imagesizes',\r\n            'as',\r\n            'color'\r\n        ]\r\n    },\r\n    style: {\r\n        attributes: ['media']\r\n    },\r\n    script: {\r\n        attributes: [\r\n            'src',\r\n            'type',\r\n            'nomodule',\r\n            'async',\r\n            'defer',\r\n            'crossorigin',\r\n            'integrity',\r\n            'referrerpolicy'\r\n        ]\r\n    },\r\n    noscript: {\r\n        attributes: false\r\n    }\r\n};\n\nfunction getTagConfigItem(tagOrName, key) {\r\n    for (const name of tagOrName) {\r\n        const tag = tags[name];\r\n        if (name && tag) {\r\n            return tag[key];\r\n        }\r\n    }\r\n}\n\n/**\r\n * Make a map and return a function for checking if a key\r\n * is in that map.\r\n * IMPORTANT: all calls of this function must be prefixed with\r\n * \\/\\*#\\_\\_PURE\\_\\_\\*\\/\r\n * So that rollup can tree-shake them if necessary.\r\n */\r\nObject.freeze({})\r\n    ;\r\nObject.freeze([]) ;\r\nconst isArray = Array.isArray;\r\nconst isFunction = (val) => typeof val === 'function';\r\nconst isString = (val) => typeof val === 'string';\r\nconst isObject = (val) => val !== null && typeof val === 'object';\r\nconst objectToString = Object.prototype.toString;\r\nconst toTypeString = (value) => objectToString.call(value);\r\nconst isPlainObject = (val) => toTypeString(val) === '[object Object]';\n\n// https://github.com/microsoft/TypeScript/issues/1863\r\nconst IS_PROXY = Symbol('kIsProxy');\r\nconst PROXY_SOURCES = Symbol('kProxySources');\r\nconst PROXY_TARGET = Symbol('kProxyTarget');\r\nconst RESOLVE_CONTEXT = Symbol('kResolveContext');\n\n// See: https://github.com/vuejs/vue-next/blob/08b4e8815da4e8911058ccbab986bea6365c3352/packages/compiler-ssr/src/transforms/ssrTransformComponent.ts\r\nfunction clone(v) {\r\n    if (isArray(v)) {\r\n        return v.map(clone);\r\n    }\r\n    if (isObject(v)) {\r\n        const res = {};\r\n        for (const key in v) {\r\n            // never clone the context\r\n            if (key === 'context') {\r\n                res[key] = v[key];\r\n            }\r\n            else {\r\n                res[key] = clone(v[key]);\r\n            }\r\n        }\r\n        return res;\r\n    }\r\n    return v;\r\n}\n\nconst pluck = (collection, key, callback) => {\r\n    const plucked = [];\r\n    for (const row of collection) {\r\n        if (row && key in row) {\r\n            plucked.push(row[key]);\r\n            if (callback) {\r\n                callback(row);\r\n            }\r\n        }\r\n    }\r\n    return plucked;\r\n};\n\nconst allKeys = (source, ...sources) => {\r\n    const keys = source ? Object.keys(source) : [];\r\n    if (sources) {\r\n        for (const source of sources) {\r\n            if (!source || !isObject(source)) {\r\n                continue;\r\n            }\r\n            for (const key in source) {\r\n                if (!keys.includes(key)) {\r\n                    keys.push(key);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    // TODO: add check for consistent types for each key (dev only)\r\n    return keys;\r\n};\r\nconst recompute = (context, path = [], target, sources) => {\r\n    const setTargetAndSources = !target && !sources;\r\n    if (setTargetAndSources) {\r\n        ({ active: target, sources } = context);\r\n        if (path.length) {\r\n            for (let i = 0; i < path.length; i++) {\r\n                const seg = path[i];\r\n                if (!target || !target[seg]) {\r\n                    if ((\"development\" !== 'production')) {\r\n                        // eslint-disable-next-line no-console\r\n                        console.error(`recompute: segment ${seg} not found on target`, path, target);\r\n                    }\r\n                    return;\r\n                }\r\n                target = target[seg];\r\n                sources = sources.map(source => source[seg]).filter(Boolean);\r\n            }\r\n        }\r\n    }\r\n    if (!target || !sources) {\r\n        return;\r\n    }\r\n    const keys = allKeys(...sources);\r\n    // Clean up properties that dont exists anymore\r\n    const targetKeys = Object.keys(target);\r\n    for (const key of targetKeys) {\r\n        if (!keys.includes(key)) {\r\n            delete target[key];\r\n        }\r\n    }\r\n    for (const key of keys) {\r\n        // This assumes consistent types usages for keys across sources\r\n        // @ts-ignore\r\n        let isObject = false;\r\n        for (let i = 0; i < sources.length; i++) {\r\n            const source = sources[i];\r\n            if (source && key in source && source[key] !== undefined) {\r\n                isObject = isPlainObject(source[key]);\r\n                break;\r\n            }\r\n        }\r\n        if (isObject) {\r\n            if (!target[key]) {\r\n                target[key] = {};\r\n            }\r\n            const keySources = [];\r\n            for (const source of sources) {\r\n                if (key in source) {\r\n                    // @ts-ignore\r\n                    keySources.push(source[key]);\r\n                }\r\n            }\r\n            recompute(context, [...path, key], target[key], keySources);\r\n            continue;\r\n        }\r\n        // Ensure the target is an array if source is an array and target is empty\r\n        // @ts-ignore\r\n        if (!target[key] && isArray(sources[0][key])) {\r\n            target[key] = [];\r\n        }\r\n        const keyContexts = [];\r\n        const keySources = pluck(sources, key, source => keyContexts.push(source[RESOLVE_CONTEXT]));\r\n        let resolved = context.resolve(keySources, keyContexts, target[key], key, path);\r\n        if (isPlainObject(resolved)) {\r\n            resolved = clone(resolved);\r\n        }\r\n        target[key] = resolved;\r\n    }\r\n};\n\nconst createProxy = (context, target, resolveContext, pathSegments = []) => {\r\n    const handler = createHandler(context, resolveContext, pathSegments);\r\n    const proxy = markRaw(new Proxy(target, handler));\r\n    if (!pathSegments.length && context.sources) {\r\n        context.sources.push(proxy);\r\n    }\r\n    return proxy;\r\n};\r\nconst createHandler = (context, resolveContext, pathSegments = []) => ({\r\n    get: (target, key, receiver) => {\r\n        if (key === IS_PROXY) {\r\n            return true;\r\n        }\r\n        if (key === PROXY_SOURCES) {\r\n            return context.sources;\r\n        }\r\n        if (key === PROXY_TARGET) {\r\n            return target;\r\n        }\r\n        if (key === RESOLVE_CONTEXT) {\r\n            return resolveContext;\r\n        }\r\n        let value = Reflect.get(target, key, receiver);\r\n        if (!isObject(value)) {\r\n            return value;\r\n        }\r\n        // Also return a merge proxy for nested objects\r\n        if (!value[IS_PROXY]) {\r\n            const keyPath = [...pathSegments, key];\r\n            value = createProxy(context, value, resolveContext, keyPath);\r\n            Reflect.set(target, key, value);\r\n        }\r\n        return value;\r\n    },\r\n    set: (target, key, value) => {\r\n        const success = Reflect.set(target, key, value);\r\n        // console.warn(success, 'PROXY SET\\nkey:', key, '\\nvalue:', value, '\\npath:', pathSegments, '\\ntarget:', isArray(target), target, '\\ncontext:\\n', context)\r\n        if (success) {\r\n            const isArrayItem = isArray(target);\r\n            let hasArrayParent = false;\r\n            let { sources: proxies, active } = context;\r\n            let activeSegmentKey;\r\n            let index = 0;\r\n            for (const segment of pathSegments) {\r\n                proxies = pluck(proxies, segment);\r\n                if (isArrayItem && index === pathSegments.length - 1) {\r\n                    activeSegmentKey = segment;\r\n                    break;\r\n                }\r\n                if (isArray(active)) {\r\n                    hasArrayParent = true;\r\n                }\r\n                active = active[segment];\r\n                index++;\r\n            }\r\n            if (hasArrayParent) {\r\n                // TODO: fix that we dont have to recompute the full merged object\r\n                // we should only have to recompute the branch that has changed\r\n                // but there is an issue here with supporting both arrays of strings\r\n                // as collections (parent vs parent of parent we need to trigger the\r\n                // update from)\r\n                recompute(context);\r\n                return success;\r\n            }\r\n            else if (isPlainObject(value)) {\r\n                // if an object was assigned to this key make sure to recompute all\r\n                // of its individual properies\r\n                recompute(context, pathSegments);\r\n                return success;\r\n            }\r\n            let keyContexts = [];\r\n            let keySources;\r\n            if (isArrayItem) {\r\n                keySources = proxies;\r\n                keyContexts = proxies.map(proxy => proxy[RESOLVE_CONTEXT]);\r\n            }\r\n            else {\r\n                keySources = pluck(proxies, key, proxy => keyContexts.push(proxy[RESOLVE_CONTEXT]));\r\n            }\r\n            let resolved = context.resolve(keySources, keyContexts, active, key, pathSegments);\r\n            // Ensure to clone if value is an object, cause sources is an array of\r\n            // the sourceProxies and not the sources so we could trigger an endless loop when\r\n            // updating a prop on an obj as the prop on the active object refers to\r\n            // a prop on a proxy\r\n            if (isPlainObject(resolved)) {\r\n                resolved = clone(resolved);\r\n            }\r\n            // console.log('SET VALUE', isArrayItem, key, '\\nresolved:\\n', resolved, '\\nsources:\\n', context.sources, '\\nactive:\\n', active, Object.keys(active))\r\n            if (isArrayItem && activeSegmentKey) {\r\n                active[activeSegmentKey] = resolved;\r\n            }\r\n            else {\r\n                active[key] = resolved;\r\n            }\r\n        }\r\n        //    console.log('CONTEXT.ACTIVE', context.active, '\\nparent:\\n', target)\r\n        return success;\r\n    },\r\n    deleteProperty: (target, key) => {\r\n        const success = Reflect.deleteProperty(target, key);\r\n        // console.warn('PROXY DELETE\\nkey:', key, '\\npath:', pathSegments, '\\nparent:', isArray(target), target)\r\n        if (success) {\r\n            const isArrayItem = isArray(target);\r\n            let activeSegmentKey;\r\n            let proxies = context.sources;\r\n            let active = context.active;\r\n            let index = 0;\r\n            for (const segment of pathSegments) {\r\n                // @ts-ignore\r\n                proxies = proxies.map(proxy => proxy && proxy[segment]);\r\n                if (isArrayItem && index === pathSegments.length - 1) {\r\n                    activeSegmentKey = segment;\r\n                    break;\r\n                }\r\n                active = active[segment];\r\n                index++;\r\n            }\r\n            // Check if the key still exists in one of the sourceProxies,\r\n            // if so resolve the new value, if not remove the key\r\n            if (proxies.some(proxy => proxy && (key in proxy))) {\r\n                let keyContexts = [];\r\n                let keySources;\r\n                if (isArrayItem) {\r\n                    keySources = proxies;\r\n                    keyContexts = proxies.map(proxy => proxy[RESOLVE_CONTEXT]);\r\n                }\r\n                else {\r\n                    keySources = pluck(proxies, key, proxy => keyContexts.push(proxy[RESOLVE_CONTEXT]));\r\n                }\r\n                let resolved = context.resolve(keySources, keyContexts, active, key, pathSegments);\r\n                if (isPlainObject(resolved)) {\r\n                    resolved = clone(resolved);\r\n                }\r\n                // console.log('SET VALUE', resolved)\r\n                if (isArrayItem && activeSegmentKey) {\r\n                    active[activeSegmentKey] = resolved;\r\n                }\r\n                else {\r\n                    active[key] = resolved;\r\n                }\r\n            }\r\n            else {\r\n                delete active[key];\r\n            }\r\n        }\r\n        return success;\r\n    }\r\n});\n\nconst createMergedObject = (resolve, active) => {\r\n    const sources = [];\r\n    const context = {\r\n        active,\r\n        resolve,\r\n        sources\r\n    };\r\n    const compute = () => recompute(context);\r\n    return {\r\n        context,\r\n        compute,\r\n        addSource: (source, resolveContext, recompute = false) => {\r\n            const proxy = createProxy(context, source, resolveContext || {});\r\n            if (recompute) {\r\n                compute();\r\n            }\r\n            return proxy;\r\n        },\r\n        delSource: (sourceOrProxy, recompute = true) => {\r\n            const index = sources.findIndex(source => source === sourceOrProxy || source[PROXY_TARGET] === sourceOrProxy);\r\n            if (index > -1) {\r\n                sources.splice(index, 1);\r\n                if (recompute) {\r\n                    compute();\r\n                }\r\n                return true;\r\n            }\r\n            return false;\r\n        }\r\n    };\r\n};\n\nconst cachedElements = {};\r\nfunction renderMeta(context, key, data, config) {\r\n    // console.info('renderMeta', key, data, config)\r\n    if ('attributesFor' in config) {\r\n        return renderAttributes(context, key, data, config);\r\n    }\r\n    if ('group' in config) {\r\n        return renderGroup(context, key, data, config);\r\n    }\r\n    return renderTag(context, key, data, config);\r\n}\r\nfunction renderGroup(context, key, data, config) {\r\n    // console.info('renderGroup', key, data, config)\r\n    if (isArray(data)) {\r\n        if ((\"development\" !== 'production')) {\r\n            // eslint-disable-next-line no-console\r\n            console.warn('Specifying an array for group properties isnt supported');\r\n        }\r\n        // config.attributes = getConfigKey([key, config.tag], 'attributes', config)\r\n        return [];\r\n    }\r\n    return Object.keys(data)\r\n        .map((childKey) => {\r\n        const groupConfig = {\r\n            group: key,\r\n            data\r\n        };\r\n        if (config.namespaced) {\r\n            groupConfig.tagNamespace = config.namespaced === true ? key : config.namespaced;\r\n        }\r\n        else if (config.namespacedAttribute) {\r\n            const namespace = config.namespacedAttribute === true ? key : config.namespacedAttribute;\r\n            groupConfig.fullName = `${namespace}:${childKey}`;\r\n            groupConfig.slotName = `${namespace}(${childKey})`;\r\n        }\r\n        return renderTag(context, key, data[childKey], config, groupConfig);\r\n    })\r\n        .filter(Boolean)\r\n        .flat();\r\n}\r\nfunction renderTag(context, key, data, config = {}, groupConfig) {\r\n    // console.info('renderTag', key, data, config, groupConfig)\r\n    const contentAttributes = ['content', 'json', 'rawContent'];\r\n    const getTagConfig = (key) => getTagConfigItem([tag, config.tag], key);\r\n    if (isArray(data)) {\r\n        return data\r\n            .map((child) => {\r\n            return renderTag(context, key, child, config, groupConfig);\r\n        })\r\n            .filter(Boolean)\r\n            .flat();\r\n    }\r\n    const { tag = config.tag || key } = data;\r\n    let content = '';\r\n    let hasChilds = false;\r\n    let isRaw = false;\r\n    if (isString(data)) {\r\n        content = data;\r\n    }\r\n    else if (data.children && isArray(data.children)) {\r\n        hasChilds = true;\r\n        content = data.children.map((child) => {\r\n            const data = renderTag(context, key, child, config, groupConfig);\r\n            if (isArray(data)) {\r\n                return data.map(({ vnode }) => vnode);\r\n            }\r\n            return data && data.vnode;\r\n        });\r\n    }\r\n    else {\r\n        let i = 0;\r\n        for (const contentAttribute of contentAttributes) {\r\n            if (!content && data[contentAttribute]) {\r\n                if (i === 1) {\r\n                    content = JSON.stringify(data[contentAttribute]);\r\n                }\r\n                else {\r\n                    content = data[contentAttribute];\r\n                }\r\n                isRaw = i > 1;\r\n                break;\r\n            }\r\n            i++;\r\n        }\r\n    }\r\n    const fullName = (groupConfig && groupConfig.fullName) || key;\r\n    const slotName = (groupConfig && groupConfig.slotName) || key;\r\n    let { attrs: attributes } = data;\r\n    if (!attributes && typeof data === 'object') {\r\n        attributes = { ...data };\r\n        delete attributes.tag;\r\n        delete attributes.children;\r\n        delete attributes.to;\r\n        // cleanup all content attributes\r\n        for (const attr of contentAttributes) {\r\n            delete attributes[attr];\r\n        }\r\n    }\r\n    else if (!attributes) {\r\n        attributes = {};\r\n    }\r\n    if (hasChilds) {\r\n        content = getSlotContent(context, slotName, content, data);\r\n    }\r\n    else {\r\n        const contentAsAttribute = !!getTagConfig('contentAsAttribute');\r\n        let { valueAttribute } = config;\r\n        if (!valueAttribute && contentAsAttribute) {\r\n            const [tagAttribute] = getTagConfig('attributes');\r\n            valueAttribute = isString(contentAsAttribute) ? contentAsAttribute : tagAttribute;\r\n        }\r\n        if (!valueAttribute) {\r\n            content = getSlotContent(context, slotName, content, data);\r\n        }\r\n        else {\r\n            const { nameless } = config;\r\n            if (!nameless) {\r\n                const keyAttribute = config.keyAttribute || getTagConfig('keyAttribute');\r\n                if (keyAttribute) {\r\n                    attributes[keyAttribute] = fullName;\r\n                }\r\n            }\r\n            attributes[valueAttribute] = getSlotContent(context, slotName, attributes[valueAttribute] || content, groupConfig);\r\n            content = '';\r\n        }\r\n    }\r\n    const finalTag = groupConfig && groupConfig.tagNamespace\r\n        ? `${groupConfig.tagNamespace}:${tag}`\r\n        : tag;\r\n    if (finalTag === 'title' && !context.isSSR) {\r\n        document.title = content;\r\n        return;\r\n    }\r\n    // console.info('FINAL TAG', finalTag)\r\n    // console.log('      ATTRIBUTES', attributes)\r\n    // console.log('      CONTENT', content)\r\n    // console.log(data, attributes, config)\r\n    if (isRaw && content) {\r\n        attributes.innerHTML = content;\r\n    }\r\n    // Ignore empty string content\r\n    const vnode = h(finalTag, attributes, content || undefined);\r\n    return {\r\n        to: data.to,\r\n        vnode\r\n    };\r\n}\r\nfunction renderAttributes(context, key, data, config) {\r\n    // console.info('renderAttributes', key, data, config)\r\n    const { attributesFor } = config;\r\n    if (!attributesFor || !data) {\r\n        return;\r\n    }\r\n    if (context.isSSR) {\r\n        // render attributes in a placeholder vnode so Vue\r\n        // will render the string for us\r\n        return {\r\n            to: '',\r\n            vnode: h(`ssr-${attributesFor}`, data)\r\n        };\r\n    }\r\n    if (!cachedElements[attributesFor]) {\r\n        const [el, el2] = Array.from(document.querySelectorAll(attributesFor));\r\n        if ((\"development\" !== 'production') && !el) {\r\n            // eslint-disable-next-line no-console\r\n            console.error('Could not find element for selector', attributesFor, ', won\\'t render attributes');\r\n            return;\r\n        }\r\n        if ((\"development\" !== 'production') && el2) {\r\n            // eslint-disable-next-line no-console\r\n            console.warn('Found multiple elements for selector', attributesFor);\r\n        }\r\n        cachedElements[attributesFor] = {\r\n            el,\r\n            attrs: []\r\n        };\r\n    }\r\n    const { el, attrs } = cachedElements[attributesFor];\r\n    for (const attr in data) {\r\n        let content = getSlotContent(context, `${key}(${attr})`, data[attr], data);\r\n        if (isArray(content)) {\r\n            content = content.join(',');\r\n        }\r\n        el.setAttribute(attr, content || '');\r\n        if (!attrs.includes(attr)) {\r\n            attrs.push(attr);\r\n        }\r\n    }\r\n    const attrsToRemove = attrs.filter(attr => !data[attr]);\r\n    for (const attr of attrsToRemove) {\r\n        el.removeAttribute(attr);\r\n    }\r\n}\r\nfunction getSlotContent({ metainfo, slots }, slotName, content, groupConfig) {\r\n    const slot = slots && slots[slotName];\r\n    if (!slot || !isFunction(slot)) {\r\n        return content;\r\n    }\r\n    const slotScopeProps = {\r\n        content,\r\n        metainfo\r\n    };\r\n    if (groupConfig && groupConfig.group) {\r\n        const { group, data } = groupConfig;\r\n        slotScopeProps[group] = data;\r\n    }\r\n    const slotContent = slot(slotScopeProps);\r\n    if (slotContent && slotContent.length) {\r\n        const { children } = slotContent[0];\r\n        return children ? children.toString() : '';\r\n    }\r\n    return content;\r\n}\n\nconst hasSymbol = typeof Symbol === 'function' && typeof Symbol.toStringTag === 'symbol';\r\nconst PolySymbol = (name) => \r\n// vm = vue meta\r\nhasSymbol\r\n    ? Symbol((\"development\" !== 'production') ? '[vue-meta]: ' + name : name)\r\n    : ((\"development\" !== 'production') ? '[vue-meta]: ' : '_vm_') + name;\r\nconst metaActiveKey = /*#__PURE__*/ PolySymbol((\"development\" !== 'production') ? 'meta_active' : 'ma');\n\n/**\r\n * Apply the differences between newSource & oldSource to target\r\n */\r\nfunction applyDifference(target, newSource, oldSource) {\r\n    for (const key in newSource) {\r\n        if (!(key in oldSource)) {\r\n            target[key] = newSource[key];\r\n            continue;\r\n        }\r\n        if (isObject(target[key])) {\r\n            applyDifference(target[key], newSource[key], oldSource[key]);\r\n            continue;\r\n        }\r\n        if (newSource[key] !== oldSource[key]) {\r\n            target[key] = newSource[key];\r\n        }\r\n    }\r\n    for (const key in oldSource) {\r\n        if (!newSource || !(key in newSource)) {\r\n            delete target[key];\r\n        }\r\n    }\r\n}\n\nfunction getCurrentManager(vm) {\r\n    if (!vm) {\r\n        vm = getCurrentInstance() || undefined;\r\n    }\r\n    if (!vm) {\r\n        return undefined;\r\n    }\r\n    return vm.appContext.config.globalProperties.$metaManager;\r\n}\r\nfunction useMeta(source, manager) {\r\n    const vm = getCurrentInstance() || undefined;\r\n    if (!manager && vm) {\r\n        manager = getCurrentManager(vm);\r\n    }\r\n    if (!manager) {\r\n        throw new Error('No manager or current instance');\r\n    }\r\n    if (isProxy(source)) {\r\n        watch(source, (newSource, oldSource) => {\r\n            applyDifference(metaProxy.meta, newSource, oldSource);\r\n        });\r\n        source = source.value;\r\n    }\r\n    const metaProxy = manager.addMeta(source, vm);\r\n    return metaProxy;\r\n}\r\nfunction useActiveMeta() {\r\n    return inject(metaActiveKey);\r\n}\n\nconst MetainfoImpl = defineComponent({\r\n    name: 'Metainfo',\r\n    inheritAttrs: false,\r\n    setup(_, { slots }) {\r\n        return () => {\r\n            const manager = getCurrentManager();\r\n            if (!manager) {\r\n                return;\r\n            }\r\n            return manager.render({ slots });\r\n        };\r\n    }\r\n});\r\nconst Metainfo = MetainfoImpl;\n\nconst ssrAttribute = 'data-vm-ssr';\r\nfunction addVnode(isSSR, teleports, to, vnodes) {\r\n    const nodes = (isArray(vnodes) ? vnodes : [vnodes]);\r\n    if (!isSSR) {\r\n        // Comments shouldnt have any use on the client as they are not reactive anyway\r\n        nodes.forEach((vnode, idx) => {\r\n            if (vnode.type === Comment) {\r\n                nodes.splice(idx, 1);\r\n            }\r\n        });\r\n        // only add ssrAttribute's for real meta tags\r\n    }\r\n    else if (!to.endsWith('Attrs')) {\r\n        nodes.forEach((vnode) => {\r\n            if (!vnode.props) {\r\n                vnode.props = {};\r\n            }\r\n            vnode.props[ssrAttribute] = true;\r\n        });\r\n    }\r\n    if (!teleports[to]) {\r\n        teleports[to] = [];\r\n    }\r\n    teleports[to].push(...nodes);\r\n}\r\nconst createMetaManager = (isSSR = false, config, resolver) => MetaManager.create(isSSR, config || defaultConfig, resolver || defaultResolver);\r\nclass MetaManager {\r\n    isSSR = false;\r\n    config;\r\n    target;\r\n    resolver;\r\n    ssrCleanedUp = false;\r\n    constructor(isSSR, config, target, resolver) {\r\n        this.isSSR = isSSR;\r\n        this.config = config;\r\n        this.target = target;\r\n        if (resolver && 'setup' in resolver && isFunction(resolver.setup)) {\r\n            this.resolver = resolver;\r\n        }\r\n    }\r\n    static create = (isSSR, config, resolver) => {\r\n        const resolve = (options, contexts, active, key, pathSegments) => {\r\n            if (isFunction(resolver)) {\r\n                return resolver(options, contexts, active, key, pathSegments);\r\n            }\r\n            return resolver.resolve(options, contexts, active, key, pathSegments);\r\n        };\r\n        const active = reactive({});\r\n        const mergedObject = createMergedObject(resolve, active);\r\n        // TODO: validate resolver\r\n        const manager = new MetaManager(isSSR, config, mergedObject, resolver);\r\n        return manager;\r\n    };\r\n    install(app) {\r\n        app.component('Metainfo', Metainfo);\r\n        app.config.globalProperties.$metaManager = this;\r\n        app.provide(metaActiveKey, this.target.context.active);\r\n    }\r\n    addMeta(metadata, vm) {\r\n        if (!vm) {\r\n            vm = getCurrentInstance() || undefined;\r\n        }\r\n        const metaGuards = ({\r\n            removed: []\r\n        });\r\n        const resolveContext = { vm };\r\n        const { resolver } = this;\r\n        if (resolver && resolver.setup) {\r\n            resolver.setup(resolveContext);\r\n        }\r\n        // TODO: optimize initial compute (once)\r\n        const meta = this.target.addSource(metadata, resolveContext, true);\r\n        const onRemoved = (removeGuard) => metaGuards.removed.push(removeGuard);\r\n        const unmount = (ignoreGuards) => this.unmount(!!ignoreGuards, meta, metaGuards, vm);\r\n        if (vm) {\r\n            onUnmounted(unmount);\r\n        }\r\n        return {\r\n            meta,\r\n            onRemoved,\r\n            unmount\r\n        };\r\n    }\r\n    unmount(ignoreGuards, meta, metaGuards, vm) {\r\n        if (vm) {\r\n            const { $el } = vm.proxy;\r\n            // Wait for element to be removed from DOM\r\n            if ($el && $el.offsetParent) {\r\n                let observer = new MutationObserver((records) => {\r\n                    for (const { removedNodes } of records) {\r\n                        if (!removedNodes) {\r\n                            continue;\r\n                        }\r\n                        removedNodes.forEach((el) => {\r\n                            if (el === $el && observer) {\r\n                                observer.disconnect();\r\n                                observer = undefined;\r\n                                this.reallyUnmount(ignoreGuards, meta, metaGuards);\r\n                            }\r\n                        });\r\n                    }\r\n                });\r\n                observer.observe($el.parentNode, { childList: true });\r\n                return;\r\n            }\r\n        }\r\n        this.reallyUnmount(ignoreGuards, meta, metaGuards);\r\n    }\r\n    async reallyUnmount(ignoreGuards, meta, metaGuards) {\r\n        this.target.delSource(meta);\r\n        if (!ignoreGuards && metaGuards) {\r\n            await Promise.all(metaGuards.removed.map(removeGuard => removeGuard()));\r\n        }\r\n    }\r\n    render({ slots } = {}) {\r\n        const active = this.target.context.active;\r\n        // TODO: clean this method\r\n        const { isSSR } = this;\r\n        // cleanup ssr tags if not yet done\r\n        if (!isSSR && !this.ssrCleanedUp) {\r\n            this.ssrCleanedUp = true;\r\n            const cleanUpSSR = () => {\r\n                const ssrTags = document.querySelectorAll(`[${ssrAttribute}]`);\r\n                if (ssrTags && ssrTags.length) {\r\n                    ssrTags.forEach(el => el.parentNode && el.parentNode.removeChild(el));\r\n                }\r\n            };\r\n            if (document.readyState === 'loading') {\r\n                // Listen for DOM loaded because tags in the body couldnt\r\n                // have loaded yet once the manager does it first render\r\n                // (preferable there should only be one meta render on hydration)\r\n                window.addEventListener('DOMContentLoaded', cleanUpSSR, { once: true });\r\n            }\r\n            else {\r\n                cleanUpSSR();\r\n            }\r\n        }\r\n        const teleports = {};\r\n        for (const key in active) {\r\n            const config = this.config[key] || {};\r\n            let renderedNodes = renderMeta({ isSSR, metainfo: active, slots }, key, active[key], config);\r\n            if (!renderedNodes) {\r\n                continue;\r\n            }\r\n            if (!isArray(renderedNodes)) {\r\n                renderedNodes = [renderedNodes];\r\n            }\r\n            let defaultTo = key !== 'base' && active[key].to;\r\n            if (!defaultTo && 'to' in config) {\r\n                defaultTo = config.to;\r\n            }\r\n            if (!defaultTo && 'attributesFor' in config) {\r\n                defaultTo = key;\r\n            }\r\n            for (const { to, vnode } of renderedNodes) {\r\n                addVnode(this.isSSR, teleports, to || defaultTo || 'head', vnode);\r\n            }\r\n        }\r\n        if (slots) {\r\n            for (const slotName in slots) {\r\n                const tagName = slotName === 'default' ? 'head' : slotName;\r\n                // Only teleport the contents of head/body slots\r\n                if (tagName !== 'head' && tagName !== 'body') {\r\n                    continue;\r\n                }\r\n                const slot = slots[slotName];\r\n                if (isFunction(slot)) {\r\n                    addVnode(this.isSSR, teleports, tagName, slot({ metainfo: active }));\r\n                }\r\n            }\r\n        }\r\n        return Object.keys(teleports).map((to) => {\r\n            const teleport = teleports[to];\r\n            return h(Teleport, { to }, teleport);\r\n        });\r\n    }\r\n}\n\nconst defaultOptions = {\r\n    keyName: 'metaInfo'\r\n};\r\nconst createMixin = options => ({\r\n    created() {\r\n        const instance = getCurrentInstance();\r\n        if (!instance?.type || !(options.keyName in instance.type)) {\r\n            return;\r\n        }\r\n        const metaInfo = instance.type[options.keyName];\r\n        if (isFunction(metaInfo)) {\r\n            const computedMetaInfo = computed(metaInfo.bind(this));\r\n            useMeta(computedMetaInfo);\r\n        }\r\n        else {\r\n            useMeta(metaInfo);\r\n        }\r\n    }\r\n});\r\nconst install = (app, _options = {}) => {\r\n    const options = Object.assign({}, defaultOptions, _options);\r\n    app.mixin(createMixin(options));\r\n};\n\nexport { createMetaManager, defaultResolver as deepestResolver, defaultConfig, getCurrentManager, install as plugin, resolveOption, useActiveMeta, useMeta };\n"],
  "mappings": "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",
  "names": []
}
