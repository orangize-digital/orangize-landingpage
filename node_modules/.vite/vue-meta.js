import {
  Comment,
  Teleport,
  computed,
  defineComponent,
  getCurrentInstance,
  h,
  inject,
  isProxy,
  markRaw,
  onUnmounted,
  reactive,
  watch
} from "./chunk-BPFSQ7MV.js";
import {
  __publicField,
  __spreadValues
} from "./chunk-6NXERIXR.js";

// node_modules/vue-meta/dist/vue-meta.esm-bundler.js
var resolveOption = (predicament, initialValue) => (options, contexts) => {
  let resolvedIndex = -1;
  contexts.reduce((acc, context, index) => {
    const retval = predicament(acc, context);
    if (retval !== acc) {
      resolvedIndex = index;
      return retval;
    }
    return acc;
  }, initialValue);
  if (resolvedIndex > -1) {
    return options[resolvedIndex];
  }
};
var setup = (context) => {
  let depth = 0;
  if (context.vm) {
    let { vm } = context;
    do {
      if (vm.parent) {
        depth++;
        vm = vm.parent;
      }
    } while (vm && vm.parent && vm !== vm.root);
  }
  context.depth = depth;
};
var resolve = resolveOption((currentValue, context) => {
  const { depth } = context;
  if (!currentValue || depth > currentValue) {
    return depth;
  }
  return currentValue;
});
var defaultResolver = Object.freeze({
  __proto__: null,
  setup,
  resolve
});
var defaultConfig = {
  body: {
    tag: "script",
    to: "body"
  },
  base: {
    valueAttribute: "href"
  },
  charset: {
    tag: "meta",
    nameless: true,
    valueAttribute: "charset"
  },
  description: {
    tag: "meta"
  },
  og: {
    group: true,
    namespacedAttribute: true,
    tag: "meta",
    keyAttribute: "property"
  },
  twitter: {
    group: true,
    namespacedAttribute: true,
    tag: "meta"
  },
  htmlAttrs: {
    attributesFor: "html"
  },
  headAttrs: {
    attributesFor: "head"
  },
  bodyAttrs: {
    attributesFor: "body"
  }
};
var tags = {
  title: {
    attributes: false
  },
  base: {
    contentAsAttribute: true,
    attributes: ["href", "target"]
  },
  meta: {
    contentAsAttribute: true,
    keyAttribute: "name",
    attributes: ["content", "name", "http-equiv", "charset"]
  },
  link: {
    contentAsAttribute: true,
    attributes: [
      "href",
      "crossorigin",
      "rel",
      "media",
      "integrity",
      "hreflang",
      "type",
      "referrerpolicy",
      "sizes",
      "imagesrcset",
      "imagesizes",
      "as",
      "color"
    ]
  },
  style: {
    attributes: ["media"]
  },
  script: {
    attributes: [
      "src",
      "type",
      "nomodule",
      "async",
      "defer",
      "crossorigin",
      "integrity",
      "referrerpolicy"
    ]
  },
  noscript: {
    attributes: false
  }
};
function getTagConfigItem(tagOrName, key) {
  for (const name of tagOrName) {
    const tag = tags[name];
    if (name && tag) {
      return tag[key];
    }
  }
}
Object.freeze({});
Object.freeze([]);
var isArray = Array.isArray;
var isFunction = (val) => typeof val === "function";
var isString = (val) => typeof val === "string";
var isObject = (val) => val !== null && typeof val === "object";
var objectToString = Object.prototype.toString;
var toTypeString = (value) => objectToString.call(value);
var isPlainObject = (val) => toTypeString(val) === "[object Object]";
var IS_PROXY = Symbol("kIsProxy");
var PROXY_SOURCES = Symbol("kProxySources");
var PROXY_TARGET = Symbol("kProxyTarget");
var RESOLVE_CONTEXT = Symbol("kResolveContext");
function clone(v) {
  if (isArray(v)) {
    return v.map(clone);
  }
  if (isObject(v)) {
    const res = {};
    for (const key in v) {
      if (key === "context") {
        res[key] = v[key];
      } else {
        res[key] = clone(v[key]);
      }
    }
    return res;
  }
  return v;
}
var pluck = (collection, key, callback) => {
  const plucked = [];
  for (const row of collection) {
    if (row && key in row) {
      plucked.push(row[key]);
      if (callback) {
        callback(row);
      }
    }
  }
  return plucked;
};
var allKeys = (source, ...sources) => {
  const keys = source ? Object.keys(source) : [];
  if (sources) {
    for (const source2 of sources) {
      if (!source2 || !isObject(source2)) {
        continue;
      }
      for (const key in source2) {
        if (!keys.includes(key)) {
          keys.push(key);
        }
      }
    }
  }
  return keys;
};
var recompute = (context, path = [], target, sources) => {
  const setTargetAndSources = !target && !sources;
  if (setTargetAndSources) {
    ({ active: target, sources } = context);
    if (path.length) {
      for (let i = 0; i < path.length; i++) {
        const seg = path[i];
        if (!target || !target[seg]) {
          if (true) {
            console.error(`recompute: segment ${seg} not found on target`, path, target);
          }
          return;
        }
        target = target[seg];
        sources = sources.map((source) => source[seg]).filter(Boolean);
      }
    }
  }
  if (!target || !sources) {
    return;
  }
  const keys = allKeys(...sources);
  const targetKeys = Object.keys(target);
  for (const key of targetKeys) {
    if (!keys.includes(key)) {
      delete target[key];
    }
  }
  for (const key of keys) {
    let isObject2 = false;
    for (let i = 0; i < sources.length; i++) {
      const source = sources[i];
      if (source && key in source && source[key] !== void 0) {
        isObject2 = isPlainObject(source[key]);
        break;
      }
    }
    if (isObject2) {
      if (!target[key]) {
        target[key] = {};
      }
      const keySources2 = [];
      for (const source of sources) {
        if (key in source) {
          keySources2.push(source[key]);
        }
      }
      recompute(context, [...path, key], target[key], keySources2);
      continue;
    }
    if (!target[key] && isArray(sources[0][key])) {
      target[key] = [];
    }
    const keyContexts = [];
    const keySources = pluck(sources, key, (source) => keyContexts.push(source[RESOLVE_CONTEXT]));
    let resolved = context.resolve(keySources, keyContexts, target[key], key, path);
    if (isPlainObject(resolved)) {
      resolved = clone(resolved);
    }
    target[key] = resolved;
  }
};
var createProxy = (context, target, resolveContext, pathSegments = []) => {
  const handler = createHandler(context, resolveContext, pathSegments);
  const proxy = markRaw(new Proxy(target, handler));
  if (!pathSegments.length && context.sources) {
    context.sources.push(proxy);
  }
  return proxy;
};
var createHandler = (context, resolveContext, pathSegments = []) => ({
  get: (target, key, receiver) => {
    if (key === IS_PROXY) {
      return true;
    }
    if (key === PROXY_SOURCES) {
      return context.sources;
    }
    if (key === PROXY_TARGET) {
      return target;
    }
    if (key === RESOLVE_CONTEXT) {
      return resolveContext;
    }
    let value = Reflect.get(target, key, receiver);
    if (!isObject(value)) {
      return value;
    }
    if (!value[IS_PROXY]) {
      const keyPath = [...pathSegments, key];
      value = createProxy(context, value, resolveContext, keyPath);
      Reflect.set(target, key, value);
    }
    return value;
  },
  set: (target, key, value) => {
    const success = Reflect.set(target, key, value);
    if (success) {
      const isArrayItem = isArray(target);
      let hasArrayParent = false;
      let { sources: proxies, active } = context;
      let activeSegmentKey;
      let index = 0;
      for (const segment of pathSegments) {
        proxies = pluck(proxies, segment);
        if (isArrayItem && index === pathSegments.length - 1) {
          activeSegmentKey = segment;
          break;
        }
        if (isArray(active)) {
          hasArrayParent = true;
        }
        active = active[segment];
        index++;
      }
      if (hasArrayParent) {
        recompute(context);
        return success;
      } else if (isPlainObject(value)) {
        recompute(context, pathSegments);
        return success;
      }
      let keyContexts = [];
      let keySources;
      if (isArrayItem) {
        keySources = proxies;
        keyContexts = proxies.map((proxy) => proxy[RESOLVE_CONTEXT]);
      } else {
        keySources = pluck(proxies, key, (proxy) => keyContexts.push(proxy[RESOLVE_CONTEXT]));
      }
      let resolved = context.resolve(keySources, keyContexts, active, key, pathSegments);
      if (isPlainObject(resolved)) {
        resolved = clone(resolved);
      }
      if (isArrayItem && activeSegmentKey) {
        active[activeSegmentKey] = resolved;
      } else {
        active[key] = resolved;
      }
    }
    return success;
  },
  deleteProperty: (target, key) => {
    const success = Reflect.deleteProperty(target, key);
    if (success) {
      const isArrayItem = isArray(target);
      let activeSegmentKey;
      let proxies = context.sources;
      let active = context.active;
      let index = 0;
      for (const segment of pathSegments) {
        proxies = proxies.map((proxy) => proxy && proxy[segment]);
        if (isArrayItem && index === pathSegments.length - 1) {
          activeSegmentKey = segment;
          break;
        }
        active = active[segment];
        index++;
      }
      if (proxies.some((proxy) => proxy && key in proxy)) {
        let keyContexts = [];
        let keySources;
        if (isArrayItem) {
          keySources = proxies;
          keyContexts = proxies.map((proxy) => proxy[RESOLVE_CONTEXT]);
        } else {
          keySources = pluck(proxies, key, (proxy) => keyContexts.push(proxy[RESOLVE_CONTEXT]));
        }
        let resolved = context.resolve(keySources, keyContexts, active, key, pathSegments);
        if (isPlainObject(resolved)) {
          resolved = clone(resolved);
        }
        if (isArrayItem && activeSegmentKey) {
          active[activeSegmentKey] = resolved;
        } else {
          active[key] = resolved;
        }
      } else {
        delete active[key];
      }
    }
    return success;
  }
});
var createMergedObject = (resolve2, active) => {
  const sources = [];
  const context = {
    active,
    resolve: resolve2,
    sources
  };
  const compute = () => recompute(context);
  return {
    context,
    compute,
    addSource: (source, resolveContext, recompute2 = false) => {
      const proxy = createProxy(context, source, resolveContext || {});
      if (recompute2) {
        compute();
      }
      return proxy;
    },
    delSource: (sourceOrProxy, recompute2 = true) => {
      const index = sources.findIndex((source) => source === sourceOrProxy || source[PROXY_TARGET] === sourceOrProxy);
      if (index > -1) {
        sources.splice(index, 1);
        if (recompute2) {
          compute();
        }
        return true;
      }
      return false;
    }
  };
};
var cachedElements = {};
function renderMeta(context, key, data, config) {
  if ("attributesFor" in config) {
    return renderAttributes(context, key, data, config);
  }
  if ("group" in config) {
    return renderGroup(context, key, data, config);
  }
  return renderTag(context, key, data, config);
}
function renderGroup(context, key, data, config) {
  if (isArray(data)) {
    if (true) {
      console.warn("Specifying an array for group properties isnt supported");
    }
    return [];
  }
  return Object.keys(data).map((childKey) => {
    const groupConfig = {
      group: key,
      data
    };
    if (config.namespaced) {
      groupConfig.tagNamespace = config.namespaced === true ? key : config.namespaced;
    } else if (config.namespacedAttribute) {
      const namespace = config.namespacedAttribute === true ? key : config.namespacedAttribute;
      groupConfig.fullName = `${namespace}:${childKey}`;
      groupConfig.slotName = `${namespace}(${childKey})`;
    }
    return renderTag(context, key, data[childKey], config, groupConfig);
  }).filter(Boolean).flat();
}
function renderTag(context, key, data, config = {}, groupConfig) {
  const contentAttributes = ["content", "json", "rawContent"];
  const getTagConfig = (key2) => getTagConfigItem([tag, config.tag], key2);
  if (isArray(data)) {
    return data.map((child) => {
      return renderTag(context, key, child, config, groupConfig);
    }).filter(Boolean).flat();
  }
  const { tag = config.tag || key } = data;
  let content = "";
  let hasChilds = false;
  let isRaw = false;
  if (isString(data)) {
    content = data;
  } else if (data.children && isArray(data.children)) {
    hasChilds = true;
    content = data.children.map((child) => {
      const data2 = renderTag(context, key, child, config, groupConfig);
      if (isArray(data2)) {
        return data2.map(({ vnode: vnode2 }) => vnode2);
      }
      return data2 && data2.vnode;
    });
  } else {
    let i = 0;
    for (const contentAttribute of contentAttributes) {
      if (!content && data[contentAttribute]) {
        if (i === 1) {
          content = JSON.stringify(data[contentAttribute]);
        } else {
          content = data[contentAttribute];
        }
        isRaw = i > 1;
        break;
      }
      i++;
    }
  }
  const fullName = groupConfig && groupConfig.fullName || key;
  const slotName = groupConfig && groupConfig.slotName || key;
  let { attrs: attributes } = data;
  if (!attributes && typeof data === "object") {
    attributes = __spreadValues({}, data);
    delete attributes.tag;
    delete attributes.children;
    delete attributes.to;
    for (const attr of contentAttributes) {
      delete attributes[attr];
    }
  } else if (!attributes) {
    attributes = {};
  }
  if (hasChilds) {
    content = getSlotContent(context, slotName, content, data);
  } else {
    const contentAsAttribute = !!getTagConfig("contentAsAttribute");
    let { valueAttribute } = config;
    if (!valueAttribute && contentAsAttribute) {
      const [tagAttribute] = getTagConfig("attributes");
      valueAttribute = isString(contentAsAttribute) ? contentAsAttribute : tagAttribute;
    }
    if (!valueAttribute) {
      content = getSlotContent(context, slotName, content, data);
    } else {
      const { nameless } = config;
      if (!nameless) {
        const keyAttribute = config.keyAttribute || getTagConfig("keyAttribute");
        if (keyAttribute) {
          attributes[keyAttribute] = fullName;
        }
      }
      attributes[valueAttribute] = getSlotContent(context, slotName, attributes[valueAttribute] || content, groupConfig);
      content = "";
    }
  }
  const finalTag = groupConfig && groupConfig.tagNamespace ? `${groupConfig.tagNamespace}:${tag}` : tag;
  if (finalTag === "title" && !context.isSSR) {
    document.title = content;
    return;
  }
  if (isRaw && content) {
    attributes.innerHTML = content;
  }
  const vnode = h(finalTag, attributes, content || void 0);
  return {
    to: data.to,
    vnode
  };
}
function renderAttributes(context, key, data, config) {
  const { attributesFor } = config;
  if (!attributesFor || !data) {
    return;
  }
  if (context.isSSR) {
    return {
      to: "",
      vnode: h(`ssr-${attributesFor}`, data)
    };
  }
  if (!cachedElements[attributesFor]) {
    const [el2, el22] = Array.from(document.querySelectorAll(attributesFor));
    if (!el2) {
      console.error("Could not find element for selector", attributesFor, ", won't render attributes");
      return;
    }
    if (el22) {
      console.warn("Found multiple elements for selector", attributesFor);
    }
    cachedElements[attributesFor] = {
      el: el2,
      attrs: []
    };
  }
  const { el, attrs } = cachedElements[attributesFor];
  for (const attr in data) {
    let content = getSlotContent(context, `${key}(${attr})`, data[attr], data);
    if (isArray(content)) {
      content = content.join(",");
    }
    el.setAttribute(attr, content || "");
    if (!attrs.includes(attr)) {
      attrs.push(attr);
    }
  }
  const attrsToRemove = attrs.filter((attr) => !data[attr]);
  for (const attr of attrsToRemove) {
    el.removeAttribute(attr);
  }
}
function getSlotContent({ metainfo, slots }, slotName, content, groupConfig) {
  const slot = slots && slots[slotName];
  if (!slot || !isFunction(slot)) {
    return content;
  }
  const slotScopeProps = {
    content,
    metainfo
  };
  if (groupConfig && groupConfig.group) {
    const { group, data } = groupConfig;
    slotScopeProps[group] = data;
  }
  const slotContent = slot(slotScopeProps);
  if (slotContent && slotContent.length) {
    const { children } = slotContent[0];
    return children ? children.toString() : "";
  }
  return content;
}
var hasSymbol = typeof Symbol === "function" && typeof Symbol.toStringTag === "symbol";
var PolySymbol = (name) => hasSymbol ? Symbol(true ? "[vue-meta]: " + name : name) : (true ? "[vue-meta]: " : "_vm_") + name;
var metaActiveKey = PolySymbol(true ? "meta_active" : "ma");
function applyDifference(target, newSource, oldSource) {
  for (const key in newSource) {
    if (!(key in oldSource)) {
      target[key] = newSource[key];
      continue;
    }
    if (isObject(target[key])) {
      applyDifference(target[key], newSource[key], oldSource[key]);
      continue;
    }
    if (newSource[key] !== oldSource[key]) {
      target[key] = newSource[key];
    }
  }
  for (const key in oldSource) {
    if (!newSource || !(key in newSource)) {
      delete target[key];
    }
  }
}
function getCurrentManager(vm) {
  if (!vm) {
    vm = getCurrentInstance() || void 0;
  }
  if (!vm) {
    return void 0;
  }
  return vm.appContext.config.globalProperties.$metaManager;
}
function useMeta(source, manager) {
  const vm = getCurrentInstance() || void 0;
  if (!manager && vm) {
    manager = getCurrentManager(vm);
  }
  if (!manager) {
    throw new Error("No manager or current instance");
  }
  if (isProxy(source)) {
    watch(source, (newSource, oldSource) => {
      applyDifference(metaProxy.meta, newSource, oldSource);
    });
    source = source.value;
  }
  const metaProxy = manager.addMeta(source, vm);
  return metaProxy;
}
function useActiveMeta() {
  return inject(metaActiveKey);
}
var MetainfoImpl = defineComponent({
  name: "Metainfo",
  inheritAttrs: false,
  setup(_, { slots }) {
    return () => {
      const manager = getCurrentManager();
      if (!manager) {
        return;
      }
      return manager.render({ slots });
    };
  }
});
var Metainfo = MetainfoImpl;
var ssrAttribute = "data-vm-ssr";
function addVnode(isSSR, teleports, to, vnodes) {
  const nodes = isArray(vnodes) ? vnodes : [vnodes];
  if (!isSSR) {
    nodes.forEach((vnode, idx) => {
      if (vnode.type === Comment) {
        nodes.splice(idx, 1);
      }
    });
  } else if (!to.endsWith("Attrs")) {
    nodes.forEach((vnode) => {
      if (!vnode.props) {
        vnode.props = {};
      }
      vnode.props[ssrAttribute] = true;
    });
  }
  if (!teleports[to]) {
    teleports[to] = [];
  }
  teleports[to].push(...nodes);
}
var createMetaManager = (isSSR = false, config, resolver) => MetaManager.create(isSSR, config || defaultConfig, resolver || defaultResolver);
var _MetaManager = class {
  constructor(isSSR, config, target, resolver) {
    __publicField(this, "isSSR", false);
    __publicField(this, "config");
    __publicField(this, "target");
    __publicField(this, "resolver");
    __publicField(this, "ssrCleanedUp", false);
    this.isSSR = isSSR;
    this.config = config;
    this.target = target;
    if (resolver && "setup" in resolver && isFunction(resolver.setup)) {
      this.resolver = resolver;
    }
  }
  install(app) {
    app.component("Metainfo", Metainfo);
    app.config.globalProperties.$metaManager = this;
    app.provide(metaActiveKey, this.target.context.active);
  }
  addMeta(metadata, vm) {
    if (!vm) {
      vm = getCurrentInstance() || void 0;
    }
    const metaGuards = {
      removed: []
    };
    const resolveContext = { vm };
    const { resolver } = this;
    if (resolver && resolver.setup) {
      resolver.setup(resolveContext);
    }
    const meta = this.target.addSource(metadata, resolveContext, true);
    const onRemoved = (removeGuard) => metaGuards.removed.push(removeGuard);
    const unmount = (ignoreGuards) => this.unmount(!!ignoreGuards, meta, metaGuards, vm);
    if (vm) {
      onUnmounted(unmount);
    }
    return {
      meta,
      onRemoved,
      unmount
    };
  }
  unmount(ignoreGuards, meta, metaGuards, vm) {
    if (vm) {
      const { $el } = vm.proxy;
      if ($el && $el.offsetParent) {
        let observer = new MutationObserver((records) => {
          for (const { removedNodes } of records) {
            if (!removedNodes) {
              continue;
            }
            removedNodes.forEach((el) => {
              if (el === $el && observer) {
                observer.disconnect();
                observer = void 0;
                this.reallyUnmount(ignoreGuards, meta, metaGuards);
              }
            });
          }
        });
        observer.observe($el.parentNode, { childList: true });
        return;
      }
    }
    this.reallyUnmount(ignoreGuards, meta, metaGuards);
  }
  async reallyUnmount(ignoreGuards, meta, metaGuards) {
    this.target.delSource(meta);
    if (!ignoreGuards && metaGuards) {
      await Promise.all(metaGuards.removed.map((removeGuard) => removeGuard()));
    }
  }
  render({ slots } = {}) {
    const active = this.target.context.active;
    const { isSSR } = this;
    if (!isSSR && !this.ssrCleanedUp) {
      this.ssrCleanedUp = true;
      const cleanUpSSR = () => {
        const ssrTags = document.querySelectorAll(`[${ssrAttribute}]`);
        if (ssrTags && ssrTags.length) {
          ssrTags.forEach((el) => el.parentNode && el.parentNode.removeChild(el));
        }
      };
      if (document.readyState === "loading") {
        window.addEventListener("DOMContentLoaded", cleanUpSSR, { once: true });
      } else {
        cleanUpSSR();
      }
    }
    const teleports = {};
    for (const key in active) {
      const config = this.config[key] || {};
      let renderedNodes = renderMeta({ isSSR, metainfo: active, slots }, key, active[key], config);
      if (!renderedNodes) {
        continue;
      }
      if (!isArray(renderedNodes)) {
        renderedNodes = [renderedNodes];
      }
      let defaultTo = key !== "base" && active[key].to;
      if (!defaultTo && "to" in config) {
        defaultTo = config.to;
      }
      if (!defaultTo && "attributesFor" in config) {
        defaultTo = key;
      }
      for (const { to, vnode } of renderedNodes) {
        addVnode(this.isSSR, teleports, to || defaultTo || "head", vnode);
      }
    }
    if (slots) {
      for (const slotName in slots) {
        const tagName = slotName === "default" ? "head" : slotName;
        if (tagName !== "head" && tagName !== "body") {
          continue;
        }
        const slot = slots[slotName];
        if (isFunction(slot)) {
          addVnode(this.isSSR, teleports, tagName, slot({ metainfo: active }));
        }
      }
    }
    return Object.keys(teleports).map((to) => {
      const teleport = teleports[to];
      return h(Teleport, { to }, teleport);
    });
  }
};
var MetaManager = _MetaManager;
__publicField(MetaManager, "create", (isSSR, config, resolver) => {
  const resolve2 = (options, contexts, active2, key, pathSegments) => {
    if (isFunction(resolver)) {
      return resolver(options, contexts, active2, key, pathSegments);
    }
    return resolver.resolve(options, contexts, active2, key, pathSegments);
  };
  const active = reactive({});
  const mergedObject = createMergedObject(resolve2, active);
  const manager = new _MetaManager(isSSR, config, mergedObject, resolver);
  return manager;
});
var defaultOptions = {
  keyName: "metaInfo"
};
var createMixin = (options) => ({
  created() {
    const instance = getCurrentInstance();
    if (!(instance == null ? void 0 : instance.type) || !(options.keyName in instance.type)) {
      return;
    }
    const metaInfo = instance.type[options.keyName];
    if (isFunction(metaInfo)) {
      const computedMetaInfo = computed(metaInfo.bind(this));
      useMeta(computedMetaInfo);
    } else {
      useMeta(metaInfo);
    }
  }
});
var install = (app, _options = {}) => {
  const options = Object.assign({}, defaultOptions, _options);
  app.mixin(createMixin(options));
};
export {
  createMetaManager,
  defaultResolver as deepestResolver,
  defaultConfig,
  getCurrentManager,
  install as plugin,
  resolveOption,
  useActiveMeta,
  useMeta
};
/**
 * vue-meta v3.0.0-alpha.10
 * (c) 2022
 * - Pim (@pimlie)
 * - All the amazing contributors
 * @license MIT
 */
//# sourceMappingURL=vue-meta.js.map
